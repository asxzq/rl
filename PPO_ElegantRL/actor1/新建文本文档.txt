self.delta_t = 0.005
self.max_step = 400
self.target_return = 150
self.thrust_center = np.array([0.0, -0.005, 0.0])
shaping = -100 * np.sqrt(state_out[0] * state_out[0] + state_out[1] * state_out[1] + state_out[2] * state_out[2]) \
                - 10 * np.sqrt(state_out[3] * state_out[3] + state_out[4] * state_out[4] + state_out[5] * state_out[5]) \
                - 50 * (abs(Euler[0]) + abs(Euler[1]) + abs(Euler[2]))  \
                - 50 * np.sqrt(state_out[9] * state_out[9] + state_out[10] * state_out[10] + state_out[11] * state_out[11]) \
                + 10 * state_out[13]
distance_xz = np.sqrt(self.state[0] ** 2 + self.state[2] ** 2)
        #if distance_xz > 2 * self.init_distance_xz:
            #reward = -100
            #done = True
        if self.state[1] < 0 and (not done):
            done = True

            if distance_xz <= self.init_distance_xz * 0.4:
                reward = 100
            elif distance_xz <= self.init_distance_xz * 0.8:
                reward = 30
            else:
                reward = -100

            if abs(self.state[4]) > self.max_landv:
                reward -= 60

        self.num_step += 1
        if (self.state[1] > 1.2 or self.num_step >= self.max_step) and (not done):
            reward = -100
            done = True



args.batch_size = 2 ** 8
        args.if_per_or_gae = True
        args.gamma = 0.995


self.break_step = 2 ** 23  # break training after 'total_step > break_step'
